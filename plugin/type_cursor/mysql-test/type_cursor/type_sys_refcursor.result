SET sql_mode=ORACLE;
CREATE PACKAGE DBMS_OUTPUT AS
PROCEDURE PUT_LINE(s VARCHAR);
END;
/
CREATE PACKAGE BODY DBMS_OUTPUT AS
PROCEDURE PUT_LINE(s VARCHAR) AS
BEGIN
SELECT s AS `` FROM DUAL;
END;
END;
/
CREATE FUNCTION bool_to_char(b BOOLEAN) RETURN VARCHAR AS
BEGIN
RETURN
CASE
WHEN b IS NULL THEN 'NULL'
     WHEN b         THEN 'true'
     WHEN NOT b     THEN 'false'
  END;
END;
/
SET sql_mode=DEFAULT;
#
# MDEV-20034 Add support for the pre-defined weak SYS_REFCURSOR
#
#
# Error: SYS_REFCURSOR is not allowed in a table column
#
CREATE TABLE t1 (a SYS_REFCURSOR);
ERROR HY000: Illegal parameter data type SYS_REFCURSOR for operation 'CREATE TABLE'
BEGIN NOT ATOMIC
DECLARE c0 SYS_REFCURSOR;
CREATE TABLE t1 AS SELECT c0;
SHOW CREATE TABLE t1;
END;
$$
ERROR HY000: Illegal parameter data type SYS_REFCURSOR for operation 'CREATE TABLE'
#
# Although SYS_REFCURSOR in a <select list> is not allowed in Oracle,
# let's allow it in MariaDB. It's convenient for debug purposes.
#
BEGIN NOT ATOMIC
DECLARE c0 SYS_REFCURSOR;
SELECT c0;
OPEN c0 FOR SELECT 1;
SELECT c0;
END;
$$
c0
NULL
c0
0
#
# Error: Unknown cursors
#
BEGIN NOT ATOMIC
OPEN c FOR SELECT 1;
END;
$$
ERROR 42000: Undeclared variable: c
BEGIN NOT ATOMIC
CLOSE c;
END;
$$
ERROR 42000: Undefined CURSOR: c
BEGIN NOT ATOMIC
DECLARE v INT;
CLOSE c INTO v;
END;
$$
ERROR 42000: Undefined CURSOR: c
#
# Error: Closing a not open cursor
#
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
CLOSE c;
END;
$$
ERROR 24000: Cursor is not open
#
# Error: Fetching from a not open cursor
#
BEGIN NOT ATOMIC
DECLARE a INT;
DECLARE c SYS_REFCURSOR;
FETCH c INTO a;
END;
$$
ERROR 24000: Cursor is not open
#
# Error: fetching beyond the available number of records
#
BEGIN NOT ATOMIC
DECLARE a INT;
DECLARE c SYS_REFCURSOR;
OPEN c FOR SELECT 1;
FETCH c INTO a;
FETCH c INTO a;
END;
$$
ERROR 02000: No data - zero rows fetched, selected, or processed
#
# sql_mode=ORACLE: fetching beyond the available number of records
# sets the %NOTFOUND attribute.
#
SET sql_mode=ORACLE;
DECLARE
a INT;
c SYS_REFCURSOR;
BEGIN
OPEN c FOR SELECT 1;
FETCH c INTO a;
SELECT a, c%NOTFOUND;
FETCH c INTO a;
SELECT a, c%NOTFOUND;
END;
$$
a	c%NOTFOUND
1	0
a	c%NOTFOUND
1	1
SET sql_mode=DEFAULT;
#
# Store assignment
#
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
SET c=1;
END;
$$
ERROR HY000: Cannot cast 'int' as 'sys_refcursor' in assignment of `c`
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
DECLARE i INT;
SET c=i;
END;
$$
ERROR HY000: Cannot cast 'int' as 'sys_refcursor' in assignment of `c`
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
DECLARE i INT;
SET i=c;
END;
$$
ERROR HY000: Cannot cast 'sys_refcursor' as 'int' in assignment of `i`
#
# FETCH using a SYS_REFCURSOR as a *target* variable
#
CREATE PROCEDURE p1()
BEGIN
DECLARE p1c0 SYS_REFCURSOR;
DECLARE p1c1 SYS_REFCURSOR;
OPEN p1c0 FOR SELECT 0;
OPEN p1c1 FOR SELECT 1;
FETCH p1c0 INTO p1c1;
END;
/
CALL p1;
ERROR HY000: Cannot cast 'int' as 'sys_refcursor' in assignment of `p1c1`
DROP PROCEDURE p1;
CREATE PROCEDURE p1()
BEGIN
DECLARE p1c0 SYS_REFCURSOR;
DECLARE p1c1 SYS_REFCURSOR;
OPEN p1c0 FOR SELECT 1;
FETCH p1c0 INTO p1c1;
END;
/
CALL p1;
ERROR HY000: Cannot cast 'int' as 'sys_refcursor' in assignment of `p1c1`
DROP PROCEDURE p1;
CREATE PROCEDURE p1()
BEGIN
DECLARE p1c0 SYS_REFCURSOR;
DECLARE p1c1 SYS_REFCURSOR;
DECLARE p1c2 SYS_REFCURSOR;
OPEN p1c0 FOR SELECT 1;
OPEN p1c1 FOR SELECT p1c0;
FETCH p1c1 INTO p1c2;
END;
/
CALL p1;
ERROR HY000: Illegal parameter data type SYS_REFCURSOR for operation 'CREATE TABLE'
DROP PROCEDURE p1;
#
# Aggregate functions
#
BEGIN NOT ATOMIC
DECLARE c0 SYS_REFCURSOR;
SELECT SUM(c0);
END;
$$
ERROR HY000: Illegal parameter data type sys_refcursor for operation 'sum'
BEGIN NOT ATOMIC
DECLARE c0 SYS_REFCURSOR;
SELECT AVG(c0);
END;
$$
ERROR HY000: Illegal parameter data type sys_refcursor for operation 'avg'
BEGIN NOT ATOMIC
DECLARE c0 SYS_REFCURSOR;
SELECT VARIANCE(c0);
END;
$$
ERROR HY000: Illegal parameter data type sys_refcursor for operation 'variance('
#
# Flow control
#
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
IF c THEN
SELECT 'TRUE';
ELSE
SELECT 'NOT TRUE';
END IF;
END;
$$
ERROR HY000: Illegal parameter data type sys_refcursor for operation 'IF'
BEGIN NOT ATOMIC
DECLARE c SYS_REFCURSOR;
CASE c WHEN TRUE THEN
SELECT 'TRUE';
ELSE
SELECT 'NOT TRUE';
END CASE;
END;
$$
ERROR HY000: Illegal parameter data types sys_refcursor and boolean for operation '='
#
# OPEN is not allowed for IN SYS_REFCURSOR parameters
#
SET sql_mode=ORACLE;
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
BEGIN
OPEN p1c0 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
END;
/
ERROR 42000: This version of MariaDB doesn't yet support 'OPEN IN_sp_parameter'
SET sql_mode=DEFAULT;
#
# FETCH and CLOSE are allowed for IN SYS_REFCURSOR parameters
#
SET sql_mode=ORACLE;
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
p1c1 SYS_REFCURSOR DEFAULT p1c0;
v0 INT;
v1 INT;
BEGIN
FETCH p1c1 INTO v0;
OPEN p1c1 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
FETCH p1c1 INTO v1;
DBMS_OUTPUT.PUT_LINE(v0 || ' ' || v1);
CLOSE p1c0;
END;
/
CREATE PROCEDURE p2 AS
p2c0 SYS_REFCURSOR;
BEGIN
OPEN p2c0 FOR SELECT 21 FROM DUAL UNION SELECT 22 FROM DUAL;
p1(p2c0);
DBMS_OUTPUT.PUT_LINE('p2c0%ISOPEN' ||'='|| bool_to_char(p2c0%ISOPEN));
END;
/
CALL p2;

21 11

p2c0%ISOPEN=false
DROP PROCEDURE p1;
DROP PROCEDURE p2;
SET sql_mode=DEFAULT;
#
# OPEN is allowed for an IN parameter alias
#
SET sql_mode=ORACLE;
CREATE PROCEDURE p1(p1c0 IN SYS_REFCURSOR) AS
p1c1 SYS_REFCURSOR DEFAULT p1c0;
v0 INT;
v1 INT;
BEGIN
FETCH p1c1 INTO v0;
OPEN p1c1 FOR SELECT 11 FROM DUAL UNION SELECT 12 FROM DUAL;
FETCH p1c1 INTO v1;
DBMS_OUTPUT.PUT_LINE(v0 || ' ' || v1);
CLOSE p1c0;
END;
/
CREATE PROCEDURE p2 AS
p2c0 SYS_REFCURSOR;
BEGIN
OPEN p2c0 FOR SELECT 21 FROM DUAL UNION SELECT 22 FROM DUAL;
p1(p2c0);
DBMS_OUTPUT.PUT_LINE('p2c0%ISOPEN' ||'='|| bool_to_char(p2c0%ISOPEN));
END;
/
CALL p2;

21 11

p2c0%ISOPEN=false
DROP PROCEDURE p1;
DROP PROCEDURE p2;
SET sql_mode=DEFAULT;
#
# Fetching from a SYS_REFCURSOR into a ROW type variable
#
SET sql_mode=ORACLE;
CREATE TABLE t1 (a INT, b VARCHAR(32));
INSERT INTO t1 VALUES (1, 'b1');
CREATE PROCEDURE p1 AS
c0 SYS_REFCURSOR;
r0 t1%ROWTYPE;
BEGIN
OPEN c0 FOR SELECT * FROM t1;
FETCH c0 INTO r0;
DBMS_OUTPUT.PUT_LINE(r0.a ||' '|| r0.b);
END;
/
CALL p1;

1 b1
DROP TABLE t1;
DROP PROCEDURE p1;
#
# %TYPE for SYS_REFCURSOR variables
#
SET sql_mode=ORACLE;
CREATE PROCEDURE p1 AS
c0 SYS_REFCURSOR;
c1 c0%TYPE;
v1 INT;
v2 INT;
BEGIN
OPEN c0 FOR SELECT 1 AS c1, 2 AS c2 FROM DUAL;
c1:= c0;
FETCH c1 INTO v1, v2;
DBMS_OUTPUT.PUT_LINE(v1 ||' '|| v2);
END;
/
CALL p1;

1 2
DROP PROCEDURE p1;
#
# %ROWTYPE does not work for SYS_REFCURSOR variables
#
SET sql_mode=ORACLE;
CREATE PROCEDURE p1 AS
c0 SYS_REFCURSOR;
BEGIN
OPEN c0 FOR SELECT 1 AS c1, 2 AS c2 FROM DUAL;
DECLARE
r c0%ROWTYPE; -- This is considered as a table c0.
BEGIN
CREATE TABLE t1 AS SELECT r.c1 AS c1, r.c2 AS c2;
END;
END;
/
CALL p1;
ERROR 42S02: Table 'test.c0' doesn't exist
DROP PROCEDURE p1;
DROP PACKAGE dbms_output;
DROP FUNCTION bool_to_char;
